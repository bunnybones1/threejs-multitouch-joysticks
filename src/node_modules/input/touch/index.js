var EventUtil = require('browser-event-adder');
var canvas = require('canvas');
var arrayish = require('util/arrayish');

var initd = false;

var lockoutDurationFrames = 3;
var identifiersStarting;
var activeHandlers;
var locking;

var startingTouches;

function onEnterFrame() {
	if(locking > -1) {
		locking--;
		if(locking === 0) {
			startCutoffPeriod();
		}
	}
}

function registerHandler (handler) {
	if(handler.touches === undefined
		|| handler.onStart === undefined
		|| handler.onMove === undefined
		|| handler.onEnd === undefined
		|| handler.name === undefined
	) {
		throw new Error('Missing something.');
	}
	registeredHandlers[handler.touches] = handler;
}

function mapTouches(touch) {
	return {
		identifier: touch.identifier,
		timeStamp: touch.timeStamp,
		clientX: touch.clientX,
		clientY: touch.clientY
	}
}
function touchStartHandler (event) {
	console.log('touch start');
	event.preventDefault();
	var changedTouches = arrayish.map(event.changedTouches, mapTouches);
	arrayish.forEach(changedTouches, function(touch){
		identifiersStarting.push(touch.identifier);
		startingTouches[touch.identifier] = touch;
		locking = lockoutDurationFrames;
	});
}

function startCutoffPeriod () {
	console.log('lockout! touches caught:', identifiersStarting.length);
	var touches = startingTouches.filter(function(touch){
		if(touch && identifiersStarting.has(touch.identifier)) return touch;
	});
	var handler = registeredHandlers[identifiersStarting.length];
	if(handler) {
		handler.identifierGroups.push(identifiersStarting.slice()),
		handler.onStart(touches);
		activeHandlers.pushIfHasNot(handler);
	}
	identifiersStarting.length = 0;
	console.log('active handlers:', activeHandlers.length);
}

function touchEndHandler (event) {
	console.log('touch end');
	event.preventDefault();
	arrayish.forEach(event.changedTouches, function(touch) {
		identifiersStarting.removeIfHas(touch.identifier);
	});
	var closingHandler;
	var closingHandlerIdentifiers;
	activeHandlers.forEach(function(handler){
		handler.identifierGroups.forEach(function(identifiers) {
			arrayish.forEach(event.changedTouches, function(touch) {
				if(identifiers.has(touch.identifier)) {
					if(closingHandler) throw new Error("Cannot close multiple handlers at once.");
					closingHandler = handler;
					closingHandlerIdentifiers = identifiers;
				}
			});
		});
	});
	if(closingHandler) {
		var implicatedChangedTouches = arrayish.filter(event.changedTouches, function(touch) {
			return closingHandlerIdentifiers.has(touch.identifier);
		});
		var implicatedTouches = arrayish.filter(event.touches, function(touch) {
			return closingHandlerIdentifiers.has(touch.identifier);
		});
		closingHandler.onEnd(implicatedTouches.concat(implicatedChangedTouches));
		closingHandler.identifierGroups.removeIfHas(closingHandlerIdentifiers);
		if(closingHandler.identifierGroups.length === 0) activeHandlers.removeIfHas(closingHandler);
	}
	console.log('active handlers:', activeHandlers.length);
}

function touchMoveHandler (event) {
	event.preventDefault();

	activeHandlers.forEach(function(handler) {
		handler.identifierGroups.forEach(function(identifiers) {
			handler.onMove(arrayish.filter(event.touches, function(touch) {
				return identifiers.has(touch.identifier);
			}));
		});
	});
}


function init() {
	if(initd) return;
	initd = true;

	identifiersStarting = [];
	activeHandlers = [];

	startingTouches = [];


	for (var i = 0; i < startingTouches.length; i++) {
		startingTouches[i] = undefined;
	};

	registeredHandlers = [];
	for (var i = 0; i < registeredHandlers.length; i++) {
		registeredHandlers[i] = null;
	};

	EventUtil.addEvent(canvas.canvas, 'touchstart', touchStartHandler);
	EventUtil.addEvent(canvas.canvas, 'touchmove', touchMoveHandler);
	EventUtil.addEvent(canvas.canvas, 'touchend', touchEndHandler);

	exports.registerHandler = registerHandler;
	exports.onEnterFrame = onEnterFrame;
	delete exports.init;
}

exports = {
	init: init
};

module.exports = exports;