var Checkerboard = require('threejs-texture-checkerboard');
var three = require('three');
var world = require('world');
var view = require('view');
var TestPlane = require('./TestPlane');

var initd = false;

var items = [];

function init() {
	if(initd) return;
	initd = true;

	var scene = world.scene;

	var geometry = new three.PlaneGeometry(1, 1, 1, 1);

	var material = new three.ShaderMaterial({
		color: new three.Color(Math.random() * 0.5, 0.6, 0.5),
		depthColor: new three.Color(1, 1, 1)
	});
	for(var i = 0; i < 200; i++) {
		var testPlane = new TestPlane();
		testPlane.position.set(
			Math.random() * 15000, 
			Math.random() * 700, 
			(1-Math.pow(Math.random(), 2)) * -120 - 20
		);
		testPlane.parallax = testPlane.position.z / -1000;
		testPlane.scale.set(
			Math.random() * 50 + 150, 
			Math.random() * 50 + 150, 
			1
		);
		// testPlane.rotation.z = (Math.random() - 0.5) * 0.2;
		scene.add(testPlane);

		items.push(testPlane);
		registerTeleportee(testPlane);
	}

	exports.teleport = teleport;
	exports.preRender = preRender;
	delete exports.init;
}

var teleportees = [];
function teleport(distance) {
	teleportees.forEach(function(teleportee) {
		teleportee.position.x += distance * (1-teleportee.parallax);
	});
}

function registerTeleportee(object) {
	teleportees.push(object);
}

function deregisterTeleportee(object) {
	var index = teleportees.indexOf(object);
	if(index !== -1) {
		teleportees.splice(index, 1);
	}
}

function preRender() {
	var dx = view.centerDelta.x;
	var dy = view.centerDelta.y;
	items.forEach(function(item) {
		item.position.x += dx * item.parallax;
		item.position.y += dy * item.parallax;
		var antiParallax = 1 - item.parallax;
		if(item.position.x < -800){
			item.position.x += 1600;
		} else if(item.position.x > 800) {
			item.position.x -= 1600;
		}
	});
}

exports = {
	init: init
};

module.exports = exports;