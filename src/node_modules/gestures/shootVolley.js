var lerp = require('lerp');
var three = require('three');
var world = require('world');
var physics = require('physics');
var view = require('view');
var eases = require('eases');

var meshes = [];
for (var i = 0; i < 20; i++) {
	meshes[i] = null;
};
var identifierGroups = [];
var callback = function(vx, vy) {
	console.log('FIRE VOLLEY!', vx, vy);
}
function setCallback(value) {
	callback = value;
}

var shootGesture = {
	touches: 2,
	name: 'shootVolley',
	identifierGroups: identifierGroups,

	onStart: onStart,
	onMove: onMove,
	onEnd: onEnd,
	updateCameraOffset: updateCameraOffset,
	setCallback: setCallback
}

var extraTouches = 2;

var cameraLeft = 0;
var cameraBottom = 0;

function updateCameraOffset(left, bottom) {
	cameraLeft = left;
	cameraBottom = bottom;
	updateMeshes();
}

function updateMeshes() {
	identifierGroups.forEach(function(identifiers) {
		identifiers.forEach(function(id) {
			updateMesh(meshes[id]);
			if(meshes[id].extraMeshes) {
				meshes[id].extraMeshes.forEach(function(extraMesh) {
					updateMesh(extraMesh);
				})
			}
		});
	});
}

var euler = new three.Euler(0, 0, 0, 'ZXY');
function updateMesh(mesh) {
	mesh.position.set(cameraLeft + mesh.x * view.width, cameraBottom + mesh.y * view.height, 900);
	var deltaX = (mesh.x - mesh.originX) * view.screenWidth / view.height;
	var deltaY = (mesh.y - mesh.originY) * view.screenHeight / view.height;
	var length = mesh.length;
	var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	distance /= view.screenWidth / view.width;
	var scale = (eases.quintIn(1 - Math.min(distance, 1) / 1) * 0.75 + 0.25) * view.width / view.screenWidth;
	mesh.scale.x = scale * 100;
	mesh.scale.y = scale * 100;
	mesh.scale.z = scale * 100;
	// length /= view.width / view.screenWidth;
	var angle = Math.atan2(distance, (length-distance)) * 20;
	euler.x = angle - Math.PI * 0.5;
	euler.z = Math.atan2(deltaY, deltaX) + Math.PI * 0.5;
	mesh.setRotationFromEuler(euler);
}

function updatePosition(id, x, y) {
	var mesh = meshes[id];
	mesh.x = x / view.screenWidth;
	mesh.y = y / view.screenHeight;
	updateMesh(mesh);
}

var material;
function getMaterial() {
	if(!material) material = new three.MeshBasicMaterial({
		color: 0xff0000,
		transparent: true,
		opacity: 0.75,
		// wireframe: true,
		depthTest: false
	});
	return material;
}

var geometry;
function getGeometry(length) {
	if(length === undefined) throw new Error('You must provide a length');
	length -= 0.5;
	var segsV = 8;
	var segsU = 16;
	if(!geometry) {
		geometry = new three.SphereGeometry(0.5, segsU, segsV);
		var vertices = geometry.vertices;
		for (var iv = 0; iv <= segsV * 0.5; iv++) {
			var u = vertices[iv*(segsU+1)].y;
			u += Math.pow(u * 2, 20) * length;
			for (var iu = 0; iu <= segsU; iu++) {
				vertices[iv*(segsU+1) + iu].y = u;
			};
		};
		geometry.verticesNeedUpdate = true;

	}
	return geometry;
}
var geometryExtra;
function getGeometryExtra(length) {
	if(length === undefined) throw new Error('You must provide a length');
	length -= 0.5;
	var segsV = 3;
	var segsU = 16;
	if(!geometryExtra) {
		geometryExtra = new three.SphereGeometry(0.5, segsU, segsV);
		var vertices = geometryExtra.vertices;
		for (var iv = 0; iv <= segsV * 0.5; iv++) {
			var u = vertices[iv*(segsU+1)].y;
			u += Math.pow(u * 2, 20) * length;
			for (var iu = 0; iu <= segsU; iu++) {
				vertices[iv*(segsU+1) + iu].y = u;
			};
		};
		vertices.forEach(function(vertex) {
			vertex.x *= 0.2;
			vertex.z *= 0.2;
		})
		geometryExtra.verticesNeedUpdate = true;

	}
	return geometryExtra;
}

function onStart(touches) {
	var newMeshes = [];
	var length = 20;
	touches.forEach(function(touch){
		id = touch.identifier;
		if(!meshes[id]) {
			meshes[id] = new three.Mesh(getGeometry(length), getMaterial());
			meshes[id].length = length + 0.5;
			meshes[id].renderOrder = 1000;
			meshes[id].position.z = 900;
			meshes[id].scale.set(1, 1, 1);
		}
		if(!meshes[id].parent) {
			world.scene.add(meshes[id]);
		}
		
		var x = touch.clientX;
		var y = view.screenHeight - touch.clientY;

		meshes[id].originX = x / view.screenWidth;
		meshes[id].originY = y / view.screenHeight;
		updatePosition(id, x, y);

		newMeshes.push(meshes[id]);
	});

	if(!meshes[id].extraMeshes) {
		meshes[id].extraMeshes = [];
	}

	for (var i = 0; i < extraTouches; i++) {
		var ratio = (i + 1) / 3;
		var extraMesh = new three.Mesh(getGeometryExtra(length), getMaterial());
		extraMesh.length = length + 0.5;
		extraMesh.renderOrder = 1000;
		extraMesh.position.z = 900;
		extraMesh.scale.set(1, 1, 1);
		extraMesh.originX = lerp(newMeshes[0].originX, newMeshes[1].originX, ratio);
		extraMesh.originY = lerp(newMeshes[0].originY, newMeshes[1].originY, ratio);
		if(!extraMesh.parent) {
			world.scene.add(extraMesh);
		}
		meshes[id].extraMeshes.push(extraMesh);
	};
}

function onMove(touches) {
	var currentMeshes = [];
	var extraMeshes;
	touches.forEach(function(touch){
		var id = touch.identifier;
		var x = touch.clientX;
		var y = view.screenHeight - touch.clientY;
		updatePosition(id, x, y);
		extraMeshes = meshes[id].extraMeshes || extraMeshes;
		currentMeshes.push(meshes[id]);
	});
	for (var i = 0; i < extraTouches; i++) {
		var ratio = (i + 1) / 3;
		extraMeshes[i].x = lerp(currentMeshes[0].x, currentMeshes[1].x, ratio);
		extraMeshes[i].y = lerp(currentMeshes[0].y, currentMeshes[1].y, ratio);
		updateMesh(extraMeshes[i]);
	}
}

function onEnd(touches) {
	var currentMeshes = [];
	touches.forEach(function(touch){
		var id = touch.identifier;
		var x = touch.clientX;
		var y = view.screenHeight - touch.clientY;
		updatePosition(id, x, y);
		if(meshes[id].parent) {
			world.scene.remove(meshes[id]);
		}
		if(meshes[id].extraMeshes) {
			meshes[id].extraMeshes.forEach(function(extraMesh) {
				if(extraMesh.parent) {
					extraMesh.parent.remove(extraMesh);
				}
			})
			meshes[id].extraMeshes.length = 0;
		}
		currentMeshes.push(meshes[id]);
	});
	var mesh = currentMeshes[0];
	var vx = mesh.x - mesh.originX;
	var vy = (mesh.y - mesh.originY) * view.aspectRatio;
	var mesh = currentMeshes[1];
	var vx2 = mesh.x - mesh.originX;
	var vy2 = (mesh.y - mesh.originY) * view.aspectRatio;
	for(var i = 0; i < 10; i++) {
		callback(lerp(vx, vx2, Math.random()), lerp(vy, vy2, Math.random()));
	}
}
module.exports = shootGesture;