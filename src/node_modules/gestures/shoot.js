var three = require('three');
var world = require('world');
var physics = require('physics');
var view = require('view');
var eases = require('eases');

var meshes = [];
for (var i = 0; i < 20; i++) {
	meshes[i] = null;
};
var identifierGroups = [];
var shootGesture = {
	touches: 1,
	name: 'shoot',
	identifierGroups: identifierGroups,

	onStart: onStart,
	onMove: onMove,
	onEnd: onEnd,
	updateCameraOffset: updateCameraOffset
}


var cameraLeft = 0;
var cameraBottom = 0;

function updateCameraOffset(left, bottom) {
	cameraLeft = left;
	cameraBottom = bottom;
	updateMeshes();
}

function updateMeshes() {
	identifierGroups.forEach(function(identifiers) {
		identifiers.forEach(function(id) {
			updateMesh(meshes[id]);
		});
	});
}

var euler = new three.Euler(0, 0, 0, 'ZXY');
function updateMesh(mesh) {
	mesh.position.set(cameraLeft + mesh.x, cameraBottom + mesh.y, 900);
	var deltaX = mesh.x-mesh.originX;
	var deltaY = mesh.y-mesh.originY;
	var length = mesh.length * mesh.scale.x;
	var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	var scale = eases.quintIn(1 - Math.min(distance, 300) / 300) * 0.75 + 0.25;
	mesh.scale.x = scale * 100;
	mesh.scale.y = scale * 80;
	mesh.scale.z = scale * 100;
	var angle = Math.atan2(distance, (length-distance));
	euler.x = angle - Math.PI * 0.5;
	euler.z = Math.atan2(deltaY, deltaX) + Math.PI * 0.5;
	mesh.setRotationFromEuler(euler);
}

function updatePosition(id, x, y) {
	var mesh = meshes[id];
	mesh.x = x;
	mesh.y = y;
	updateMesh(mesh);
}

var material;
function getMaterial() {
	if(!material) material = new three.MeshBasicMaterial({
		color: 0xffffff,
		transparent: true,
		opacity: 0.75,
		// wireframe: true,
		depthTest: false
	});
	return material;
}

var geometry;
function getGeometry(length) {
	if(length === undefined) throw new Error('You must provide a length');
	length -= 0.5;
	var segsV = 8;
	var segsU = 16;
	if(!geometry) {
		geometry = new three.SphereGeometry(0.5, segsU, segsV);
		var vertices = geometry.vertices;
		for (var iv = 0; iv <= segsV * 0.5; iv++) {
			var u = vertices[iv*(segsU+1)].y;
			u += Math.pow(u * 2, 20) * length;
			for (var iu = 0; iu <= segsU; iu++) {
				vertices[iv*(segsU+1) + iu].y = u;
			};
		};
		geometry.verticesNeedUpdate = true;

	}
	return geometry;
}

function onStart(touches) {
	var x = touches[0].clientX;
	var y = view.height - touches[0].clientY;
	var id = touches[0].identifier;
	if(!meshes[id]) {
		var length = 20;
		meshes[id] = new three.Mesh(getGeometry(length), getMaterial());
		meshes[id].length = length + 0.5;
		meshes[id].renderOrder = 1000;
		meshes[id].position.z = 900;
		meshes[id].scale.set(100, 100, 100);
	}
	if(!meshes[id].parent) {
		world.scene.add(meshes[id]);
	}
	meshes[id].originX = x;
	meshes[id].originY = y;
	updatePosition(id, x, y);
}

function onMove(touches) {
	var id = touches[0].identifier;
	var x = touches[0].clientX;
	var y = view.height - touches[0].clientY;
	updatePosition(id, x, y);
}

function onEnd(touches) {
	var id = touches[0].identifier;
	var x = touches[0].clientX;
	var y = view.height - touches[0].clientY;
	updatePosition(id, x, y);
	if(meshes[id].parent) {
		world.scene.remove(meshes[id]);
	}
}
module.exports = shootGesture;