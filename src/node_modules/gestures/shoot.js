var three = require('three');
var world = require('world');
var physics = require('physics');
var view = require('view');
var eases = require('eases');

var meshes = [];
for (var i = 0; i < 20; i++) {
	meshes[i] = null;
};
var identifierGroups = [];
var callback = function(vx, vy) {
	console.log('FIRE!', vx, vy);
}
function setCallback(value) {
	callback = value;
}

var shootGesture = {
	touches: 1,
	name: 'shoot',
	identifierGroups: identifierGroups,

	onStart: onStart,
	onMove: onMove,
	onEnd: onEnd,
	updateCameraOffset: updateCameraOffset,
	setCallback: setCallback
}


var cameraLeft = 0;
var cameraBottom = 0;

function updateCameraOffset(left, bottom) {
	cameraLeft = left;
	cameraBottom = bottom;
	updateMeshes();
}

function updateMeshes() {
	identifierGroups.forEach(function(identifiers) {
		identifiers.forEach(function(id) {
			updateMesh(meshes[id]);
		});
	});
}

var euler = new three.Euler(0, 0, 0, 'ZXY');
function updateMesh(mesh) {
	mesh.position.set(cameraLeft + mesh.x * view.width, cameraBottom + mesh.y * view.height, 900);
	var deltaX = (mesh.x - mesh.originX) * view.screenWidth / view.height;
	var deltaY = (mesh.y - mesh.originY) * view.screenHeight / view.height;
	var length = mesh.length;
	var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	distance /= view.screenWidth / view.width;
	var scale = (eases.quintIn(1 - Math.min(distance, 1) / 1) * 0.75 + 0.25) * view.width / view.screenWidth;
	mesh.scale.x = scale * 100;
	mesh.scale.y = scale * 100;
	mesh.scale.z = scale * 100;
	// length /= view.width / view.screenWidth;
	var angle = Math.atan2(distance, (length-distance)) * 20;
	euler.x = angle - Math.PI * 0.5;
	euler.z = Math.atan2(deltaY, deltaX) + Math.PI * 0.5;
	mesh.setRotationFromEuler(euler);
}

function updatePosition(id, x, y) {
	var mesh = meshes[id];
	mesh.x = x / view.screenWidth;
	mesh.y = y / view.screenHeight;
	updateMesh(mesh);
}

var material;
function getMaterial() {
	if(!material) material = new three.MeshBasicMaterial({
		color: 0xffffff,
		transparent: true,
		opacity: 0.75,
		// wireframe: true,
		depthTest: false
	});
	return material;
}

var geometry;
function getGeometry(length) {
	if(length === undefined) throw new Error('You must provide a length');
	length -= 0.5;
	var segsV = 8;
	var segsU = 16;
	if(!geometry) {
		geometry = new three.SphereGeometry(0.5, segsU, segsV);
		var vertices = geometry.vertices;
		for (var iv = 0; iv <= segsV * 0.5; iv++) {
			var u = vertices[iv*(segsU+1)].y;
			u += Math.pow(u * 2, 20) * length;
			for (var iu = 0; iu <= segsU; iu++) {
				vertices[iv*(segsU+1) + iu].y = u;
			};
		};
		geometry.verticesNeedUpdate = true;

	}
	return geometry;
}

function onStart(touches) {
	var x = touches[0].clientX;
	var y = view.screenHeight - touches[0].clientY;
	var id = touches[0].identifier;
	if(!meshes[id]) {
		var length = 20;
		meshes[id] = new three.Mesh(getGeometry(length), getMaterial());
		meshes[id].length = length + 0.5;
		meshes[id].renderOrder = 1000;
		meshes[id].position.z = 900;
		meshes[id].scale.set(1, 1, 1);
	}
	if(!meshes[id].parent) {
		world.scene.add(meshes[id]);
	}
	meshes[id].originX = x / view.screenWidth;
	meshes[id].originY = y / view.screenHeight;
	updatePosition(id, x, y);
}

function onMove(touches) {
	var id = touches[0].identifier;
	var x = touches[0].clientX;
	var y = view.screenHeight - touches[0].clientY;
	updatePosition(id, x, y);
}

function onEnd(touches) {
	var id = touches[0].identifier;
	var x = touches[0].clientX;
	var y = view.screenHeight - touches[0].clientY;
	updatePosition(id, x, y);
	var mesh = meshes[id];
	if(mesh.parent) {
		world.scene.remove(mesh);
	}
	callback(mesh.x - mesh.originX, (mesh.y - mesh.originY) * view.aspectRatio);
}
module.exports = shootGesture;