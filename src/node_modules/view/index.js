var resize = require('input-resize');
var three = require('three');
var screenfull = require('screenfull');
var EventUtil = require('browser-event-adder');
var world = require('world');
var colors = require('colors');
THREE = three;

function noop() {};
var initd = false;

var renderer;
var camera;
var screenAspectRatio = 1;
var marginAmount = 0;
var bounds;


var testPlane;
var preRender = noop;
var onEnterFrame = noop;

var centerDelta = {
	x: 0,
	y: 0
}
var lastCenter = {
	x: 0,
	y: 0
}

function onResize(w, h) {
	renderer.setSize(w, h);
	screenAspectRatio = h / w;
	exports.aspectRatio = screenAspectRatio;
	exports.screenWidth = w;
	exports.screenHeight = h;
	if(bounds) updateCamera();
}

function rafTick() {
	onEnterFrame();
	preRender();
	renderer.render(world.scene, camera);
	window.requestAnimationFrame(rafTick);
}

function setOnEnterFrame(callback) {
	onEnterFrame = callback;
}

function setPreRender(callback) {
	preRender = callback;
}

function init() {
	if(initd) return;
	initd = true;
	var canvas = require('canvas');

	var colorSky = new three.Color(0.8, 0.85, 0.9);

	renderer = new three.WebGLRenderer({
		canvas: canvas.canvas,
	});
	renderer.setClearColor(colorSky);

	var pixelRatio = window.devicePixelRatio;
	// var pixelRatio = 0.5;
	renderer.setPixelRatio(pixelRatio);

	exports.pixelRatio = pixelRatio;

	camera = new three.OrthographicCamera(0, 100, 100, 0, -1000, 1000);
	camera.rotation.x = Math.PI * 0.25;
	// camera.rotation.y = Math.PI * 0.25;
	world.scene.add(camera);

	var directionalLight = new three.DirectionalLight(colors.lightgoldenrodyellow, 1);
	var ambientLight = new three.AmbientLight(colors.lightskyblue, 1);
	directionalLight.position.z = 1000;
	directionalLight.position.y = -500;
	directionalLight.position.x = -100;
	world.scene.add(directionalLight);
	world.scene.add(ambientLight);
	resize.onResize.add(onResize);
	resize.bump(onResize);

	renderer.render(world.scene, camera);

	window.requestAnimationFrame(rafTick);

	EventUtil.addEvent(canvas.canvas, 'touchend', requestFullscreen);

	delete exports.init;
	exports.setPreRender = setPreRender;
	exports.setOnEnterFrame = setOnEnterFrame;
	exports.camera = camera;
	exports.setCameraBounds = setCameraBounds;
	exports.requestFullscreen = requestFullscreen;
	exports.registerCameraOffsetCallback = registerCameraOffsetCallback;
	exports.centerDelta = centerDelta;
}

var registeredCameraOffsetCallbacks = [];
function registerCameraOffsetCallback(callback) {
	if(!callback) throw Error('You need to provide a function that accepts (left, bottom)');
	registeredCameraOffsetCallbacks.push(callback);
}

function setCameraBounds(value) {
	bounds = value;
	updateCamera();
}

function updateCamera() {
	var size = bounds.size();
	bounds.expandByScalar(size.y * marginAmount);
	var center = bounds.center();
	centerDelta.x = center.x - lastCenter.x;
	centerDelta.y = center.y - lastCenter.y;
	lastCenter.x = center.x;
	lastCenter.y = center.y;
	size = bounds.size();
	var ratioRatio = size.y / size.x / screenAspectRatio;
	if(ratioRatio > 1) {
		size.x *= ratioRatio;
	} else {
		size.y /= ratioRatio;
	}

	camera.left = size.x * -0.5 + center.x;
	camera.right = size.x * 0.5 + center.x;
	camera.top = size.y * 0.5 + center.y;
	camera.bottom = size.y * -0.5 + center.y;
	camera.updateProjectionMatrix();
	exports.width = size.x;
	exports.height = size.y;
	var left = camera.left;
	var bottom = camera.bottom;
	registeredCameraOffsetCallbacks.forEach(function(callback) {
		callback(left, bottom);
	});
}

function requestFullscreen() {
	try {
		if (screenfull.enabled) {
			screenfull.request();
		}
	} catch(e) {
		console.error(e);
	}
}

var exports = {
	screenWidth: 100,
	screenHeight: 100,
	init: init
};

module.exports = exports;