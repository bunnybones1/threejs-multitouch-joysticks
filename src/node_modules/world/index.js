var three = require('three');
var textures = require('textures');
var scenery = require('scenery');
var tweener = require('tweener');
var physics = require('physics');
var colors = require('colors');
var RenderPass = require('render-utils/RenderPass');

var initd = false;

var scene;
var marginAmount = 0;
var bounds;
var camera;
var screenAspectRatio = 1;

var centerDelta = {
	x: 0,
	y: 0
};

var lastCenter = {
	x: 0,
	y: 0
};

function init() {
	if(initd) return;
	initd = true;

	scene = new three.Scene();

	camera = new three.OrthographicCamera(0, 100, 100, 0, -1000, 1000);
	camera.rotation.x = Math.PI * 0.25;
	// camera.rotation.y = Math.PI * 0.25;
	scene.add(camera);

	var directionalLight = new three.DirectionalLight(colors.lightgoldenrodyellow, 1);
	var ambientLight = new three.AmbientLight(colors.lightskyblue, 1);
	directionalLight.position.z = 1000;
	directionalLight.position.y = -500;
	directionalLight.position.x = -100;
	scene.add(directionalLight);
	scene.add(ambientLight);

	module.exports.scene = scene;
	module.exports.camera = camera;
	module.exports.centerDelta = centerDelta;
	module.exports.getRenderPass = getRenderPass;
	module.exports.registerCameraOffsetCallback = registerCameraOffsetCallback;

	delete module.exports.init;
}

function getRenderPass() {
	return new RenderPass(scene, camera, true);
}

function onResize(w, h) {
	screenAspectRatio = h / w;
	if(bounds) updateCamera();
}

var registeredCameraOffsetCallbacks = [];
function registerCameraOffsetCallback(callback) {
	if(!callback) throw Error('You need to provide a function that accepts (left, bottom)');
	registeredCameraOffsetCallbacks.push(callback);
}

function setCameraBounds(value) {
	bounds = value;
	updateCamera();
}

function updateCamera() {
	var size = bounds.size();
	bounds.expandByScalar(size.y * marginAmount);
	var center = bounds.center();
	centerDelta.x = center.x - lastCenter.x;
	centerDelta.y = center.y - lastCenter.y;
	lastCenter.x = center.x;
	lastCenter.y = center.y;
	size = bounds.size();
	var ratioRatio = size.y / size.x / screenAspectRatio;
	if(ratioRatio > 1) {
		size.x *= ratioRatio;
	} else {
		size.y /= ratioRatio;
	}

	camera.left = size.x * -0.5 + center.x;
	camera.right = size.x * 0.5 + center.x;
	camera.top = size.y * 0.5 + center.y;
	camera.bottom = size.y * -0.5 + center.y;
	camera.updateProjectionMatrix();
	exports.width = size.x;
	exports.height = size.y;
	var left = camera.left;
	var bottom = camera.bottom;
	registeredCameraOffsetCallbacks.forEach(function(callback) {
		callback(left, bottom);
	});
}

function spawnDeathToll(person) {
	var family = {};
	family.children = [];
	family.pets = [];

	family.wife = Math.random() > 0.5 ? true : false;

	if (family.wife) {
		var numChild = ~~(Math.random() * 4);
		for (i = 0; i <= numChild; i++) { 
			family.children.push((Math.random() > 0.5) ? 'icon_boy2.png' : 'icon_girl.png');
		}
	}
	var numPets = ~~(Math.random() * 5);
	for (i = 0; i <= numPets; i++) { 
		if (Math.random() > 0.9) {
			family.pets.push('icon_goat.png');
		} else {
			family.pets.push((Math.random() > 0.5) ? 'icon_dog.png' : 'icon_cat.png');
		}
	}
	
	var cursor = 0;


	var meshes = [];
	var maxHeight = 0;
	function getMesh(filename) {
		var mesh = textures.getSprite(filename);
		mesh.position.copy(person.mesh.position);
		mesh.position.z = person.height * 0.25;
		mesh.rotation.x = Math.PI * 0.25;
		mesh.scale.multiplyScalar(0.25);
		cursor += mesh.scale.x * 0.5;
		mesh.position.x += cursor;
		mesh.position.z += mesh.scale.y* 0.5;
		cursor += mesh.scale.x * 0.5;
		scene.add(mesh);
		maxHeight = Math.max(maxHeight, mesh.scale.y);
		meshes.push(mesh);
	}
	if (family.wife) {
		getMesh('icon_wife.png', person);
	}
	family.children.forEach(function(child) {
		getMesh(child, person);
	});
	family.pets.forEach(function(pet) {
		getMesh(pet, person);
	});

	meshes.forEach(function(mesh, i) {
		mesh.position.x -= cursor * 0.5;
		tweener.to(
			mesh.position, 
			2,
			{
				z: mesh.position.z + 200,
				delay: i * 0.2,
				onComplete: function() {
					mesh.parent.remove(mesh);
				}
			}
		);
		scenery.registerTeleportee(mesh);
	});

}

function targetSpriteAt(position) {
	var mesh = textures.getSprite('target.png');
	mesh.position.x = position.x * physics.SCALE_INV;
	mesh.position.y = position.y * physics.SCALE_INV;
	mesh.scale.multiplyScalar(0.3);
	scene.add(mesh);
	tweener.to(mesh.scale, 0.5, {
		x: mesh.scale.x + 50,
		y: mesh.scale.y + 50,
		onComplete: function() {
			mesh.parent.remove(mesh);
		}
	});
}

module.exports = {
	init: init,
	death:spawnDeathToll,
	targetSpriteAt: targetSpriteAt,
	onResize: onResize,
	setCameraBounds: setCameraBounds
};