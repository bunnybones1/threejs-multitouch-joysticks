var three = require('three');
var triangulate = require('shape2d-triangulate');
var Shape = require('shape2d');
var eases = require('eases');
var getRatioBetween = require('math/getRatioBetween');

var vertexShader = [
	'attribute vec3 custom;',
	'varying vec3 vCustom;',
	'void main() {',
	'	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
	'	vCustom = custom;',
	'}'
].join('\n');

var fragmentShader = [
	'uniform float health;',
	'uniform vec3 colorOn;',
	'uniform vec3 colorOff;',
	'uniform float phase;',
	'varying vec3 vCustom;',
	'void main() {',
	'	float healthColor = clamp(((vCustom.y + sin(vCustom.x+phase) * 0.02) - health) * 100.0, 0.0, 1.0);',
	'	gl_FragColor = vec4(mix(colorOff, colorOn, healthColor), 1.0);',
	'}'
].join('\n');

var geometry;

function getGeometry() {
	if(!geometry) {
		geometry = new three.BufferGeometry();
		var cursor = {x:0, y:0};
		var angle = -Math.PI * 0.25 - 0.05;
		var segments = 5;
		var angleChange = -(Math.PI*2) / segments;
		var stepSize = 120/segments;
		var shapePoints = [{x:0, y:0}];
		for (var i = 0; i < segments; i++) {
			angle += eases.quartInOut(i / (segments-1)) * angleChange;
			cursor.x += Math.cos(angle) * stepSize;
			cursor.y += Math.sin(angle) * stepSize;
			shapePoints.push({x:cursor.x, y:cursor.y});
		}
		shapePoints[0].x = 0;
		shapePoints[shapePoints.length-1].x = 0;
		for (var i = shapePoints.length - 2; i >= 1; i--) {
			shapePoints.push({x:-shapePoints[i].x,y:shapePoints[i].y});
		}

		var steinerPoints = [];
		var bounds = new three.Box2();
		shapePoints.forEach(function(p){
			bounds.expandByPoint(p);
		});
		var size = bounds.size();
		for (var i = 0; i < segments*6; i++) {
			steinerPoints.push({
				x: bounds.min.x + size.x * Math.random(),
				y: bounds.min.y + size.y * Math.random()
			});
		}
		var triangles = triangulate({points:shapePoints}, steinerPoints);
		var points = [];
		triangles.forEach(function(t, ti){
			t.points_.forEach(function(p, pi) {
				if(points.indexOf(p) === -1) {
					points.push(p);
				}
			});
		});
		var bufferPosition = new Float32Array(points.length*3);
		var bufferCustom = new Float32Array(points.length*3);
		var bufferIndex = new Int16Array(triangles.length*3);
		points.forEach(function(p, pi) {
			bufferPosition[pi*3] = p.x;
			bufferPosition[pi*3+1] = p.y;
			bufferPosition[pi*3+2] = Math.random();
			bufferCustom[pi*3] = getRatioBetween(p.x, bounds.min.x, bounds.max.x, 0.25);
			bufferCustom[pi*3+1] = getRatioBetween(p.y, bounds.min.y, bounds.max.y, 0.15);
			bufferCustom[pi*3+2] = Math.random();
		});
		triangles.forEach(function(t, ti){
			t.points_.forEach(function(p, pi) {
				bufferIndex[ti*3 + pi] = points.indexOf(p);
			});
		});
		geometry.addAttribute('position', 
			new three.BufferAttribute(
				bufferPosition,
				3
			)
		);
		geometry.addAttribute('index', 
			new three.BufferAttribute(
				bufferIndex,
				1
			)
		);
		geometry.addAttribute('custom', 
			new three.BufferAttribute(
				bufferCustom,
				3
			)
		);

	}
	return geometry;
}

var material;
function getMaterial() {
	if(!material) {
		var uniforms = {
			colorOn: { type: 'c', value: new THREE.Color(0.9, 0.2, 0.1) },
			colorOff: { type: 'c', value: new THREE.Color(0.2, 0.2, 0.1) },
			health: { type: 'f', value: 0.5 },
			phase: { type: 'f', value: 0.5 }
		};
		material = new three.ShaderMaterial({
			uniforms: uniforms,
			fragmentShader: fragmentShader,
			vertexShader: vertexShader,
			side: three.DoubleSide,
			// wireframe: true,
		});
	}
	return material;
}

function HealthHeart() {
	var material = getMaterial();
	three.Mesh.call(this, getGeometry(), material);
	setInterval(function() {
		material.uniforms.phase.value = ((Date.now()*0.001)%1) * Math.PI * 2;
	}, 30);
}

HealthHeart.prototype = Object.create(three.Mesh.prototype);

HealthHeart.prototype.setHealth = function(health) {
	this.material.uniforms.health.value = 1-health;
};

module.exports = HealthHeart;