var initd = false;

var view = require('view');
var world = require('world');
var Physics = require('vendor/physicsjs-full');

function init() {
	if(initd) return;
	initd = true;

	var scene = world.scene;

	var debugMeshes = [];
	Physics(function(world) {
		var viewportBounds = Physics.aabb(0, 0, view.width, view.height);

		var width = 600,
			height = 10,
			x = 300,
			y = 10;

		function addBody(body) {

			world.add(body);
			var geometry;
			if(body.width && body.height) {
				geometry = new THREE.PlaneGeometry(width, height, 1, 1);
			} else if(body.radius) {
				geometry = new THREE.SphereGeometry(body.radius, 8, 4);
			} else {
				throw new Error('I don\'t know');
			}
			var debugMesh = new THREE.Mesh(geometry);
			debugMesh.body = body;
			body.debugMesh = debugMesh;
			scene.add(debugMesh);
			debugMeshes.push(debugMesh);
		}

		var testPlatformBody = Physics.body('rectangle', {
			x: x,
			y: y,
			width: width,
			height: height,
			mass: 20,
			treatment: 'static'
		});

		addBody(testPlatformBody);
		
		y += 100;
		var radius = 30;
		for (var i = 0; i < 50; i++) {
			radius = 10 + Math.random() * 10;
			x = Math.random() * 600;
			y = Math.random() * 400;
			var testBallBody = Physics.body('circle', {
				x: x,
				y: y,
				radius: radius
			});
			addBody(testBallBody);
		}

		function onStep() {
			debugMeshes.forEach(function(debugMesh){
				debugMesh.position.x = debugMesh.body.state.pos.x;
				debugMesh.position.y = debugMesh.body.state.pos.y;
				debugMesh.rotation.z = debugMesh.body.state.angular.pos;
			});
		}

		world.on('step', onStep);

		world.add([
			Physics.behavior('constant-acceleration', {acc: { x: 0, y: -0.0004 }}),
			Physics.behavior('body-impulse-response'),
			Physics.behavior('body-collision-detection'),
			Physics.behavior('sweep-prune')
		]);

		Physics.util.ticker.on(function( time ) {
			world.step( time );
		});
	});

	delete module.exports.init;
}

module.exports = {
	init: init
};