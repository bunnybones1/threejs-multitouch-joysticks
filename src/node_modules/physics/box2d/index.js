var initd = false;

var view = require('view');
var world = require('world');
var Box2D = require('vendor/box2d');

var SCALE = 1 / 400;
var SCALE_INV = 1 / SCALE;
function init() {
	if(initd) return;
	initd = true;

	var debugMeshes = [];
	var scene = world.scene;

	var gravity = new Box2D.Common.Math.b2Vec2(0, -0.0004);
	var physicsWorld = new Box2D.Dynamics.b2World(gravity);

	var fixDef = new Box2D.Dynamics.b2FixtureDef();
	fixDef.density = 1.0;
	fixDef.friction = 0.5;
	fixDef.restitution = 0.2;

	var bodyDef = new Box2D.Dynamics.b2BodyDef();
	bodyDef.type = Box2D.Dynamics.b2Body.b2_staticBody;

	// positions the center of the object (not upper left!)
	bodyDef.position.x = 300 * SCALE;
	bodyDef.position.y = 10 * SCALE;

	fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape();
	   
	// half width, half height.
	fixDef.shape.SetAsBox(300 * SCALE, 5 * SCALE);
	fixDef.width = 600;
	fixDef.height = 10;

	function addBody(bodyDef, fixDef) {
		var geometry;
		var body = physicsWorld.CreateBody(bodyDef);
		body.CreateFixture(fixDef);
		if(fixDef.width && fixDef.height) {
			geometry = new THREE.PlaneGeometry(fixDef.width, fixDef.height, 1, 1);
		} else if(fixDef.radius) {
			geometry = new THREE.SphereGeometry(fixDef.radius, 8, 4);
		} else {
			throw new Error('I don\'t know');
		}
		var debugMesh = new THREE.Mesh(geometry);
		debugMesh.body = body;
		body.debugMesh = debugMesh;
		scene.add(debugMesh);
		debugMeshes.push(debugMesh);
	}

	addBody(bodyDef, fixDef);

	delete fixDef.width;
	delete fixDef.height;

	bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
	for(var i = 0; i < 50; ++i) {
		var radius = Math.random() * 30 + 10;
		fixDef.radius = radius;
		fixDef.shape = new Box2D.Collision.Shapes.b2CircleShape(
			radius * SCALE //radius
		);
		bodyDef.position.x = Math.random() * 600 * SCALE;
		bodyDef.position.y = Math.random() * 300 * SCALE;
		addBody(bodyDef, fixDef);
	}
	function update() {
		physicsWorld.Step(
			1 / 60,   //frame-rate
			10,       //velocity iterations
			10       //position iterations
		);

		debugMeshes.forEach(function(debugMesh){
			debugMesh.position.x = debugMesh.body.m_xf.position.x * SCALE_INV;
			debugMesh.position.y = debugMesh.body.m_xf.position.y * SCALE_INV;
		})

		physicsWorld.ClearForces();
		 
		window.requestAnimationFrame(update);
	}
	window.requestAnimationFrame(update);
	delete module.exports.init;
}

module.exports = {
	init: init
};