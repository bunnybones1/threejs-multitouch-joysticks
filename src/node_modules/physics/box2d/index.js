var initd = false;

var view = require('view');
var world = require('world');
var Box2DModule = require('vendor/box2d-emscripten');
var Box2D = Box2DModule.Box2D;
var defaults = require('lodash.defaults');

var SCALE = 1 / 400;
var SCALE_INV = 1 / SCALE;

var bodyMeshes = [];
var scene;
var avatar;
var groundBody;

var tempVec2 = new Box2D.b2Vec2(0, 0);

var gravity = new Box2D.b2Vec2(0, -4);
var physicsWorld = new Box2D.b2World(gravity);

var fixDef = new Box2D.b2FixtureDef();
var bodyDef = new Box2D.b2BodyDef();

var filter = fixDef.get_filter();

var prePhysicsCallbacks = [];

function addBody(bodyDef, fixDef, bodyMesh) {
	var geometry;
	var body = physicsWorld.CreateBody(bodyDef);
	body.CreateFixture(fixDef);
	body.SetAwake(1);
	body.SetActive(1);
	if(!bodyMesh) {
		if(fixDef.width && fixDef.height) {
			geometry = new THREE.PlaneGeometry(fixDef.width, fixDef.height, 1, 1);
		} else if(fixDef.radius) {
			geometry = new THREE.SphereGeometry(fixDef.radius, 8, 4);
		} else {
			throw new Error('Cannot deduce desired shape.');
		}
		bodyMesh = new THREE.Mesh(geometry);
	}
	bodyMesh.body = body;
	body.bodyMesh = bodyMesh;
	scene.add(bodyMesh);
	bodyMeshes.push(bodyMesh);
	return body;
}

var defaultActorParams = {
	shape: 'circle',
	staticBody: false,
	fixedRotation: false,
	mass: 1.0,
	density: 1.0,
	friction: 0.5,
	restitution: 0.2,
	x: 100,
	y: 100,
	angle: 0,
	categoryBits: 1,
	maskBits: 1,
	linearDamping: 0.1,
};

var defaultCircleParams = {
	radius: 50
};

var defaultRectangleParams = {
	width: 50,
	height: 50
};
function createPhysicsBody(params) {
	defaults(params, defaultActorParams);
	var shape;
	switch(params.shape) {
		case 'circle':
			defaults(params, defaultCircleParams);

			delete fixDef.width;
			delete fixDef.height;
			fixDef.radius = params.radius;

			shape = new Box2D.b2CircleShape();
			shape.set_m_radius(params.radius * SCALE);
			
			break;
		case 'rectangle':
			defaults(params, defaultRectangleParams);

			delete fixDef.radius;
			fixDef.width = params.width;
			fixDef.height = params.height;

			shape = new Box2D.b2PolygonShape();

			// half width, half height.
			shape.SetAsBox(params.width * 0.5 * SCALE, params.height * 0.5 * SCALE);
			fixDef.width = params.width;
			fixDef.height = params.height;

			break;
		default:
			throw new Error('unkown shape');
	}
	bodyDef.set_fixedRotation(params.fixedRotation);
	bodyDef.set_type(params.staticBody ? Box2D.b2_staticBody : Box2D.b2_dynamicBody);

	bodyDef.set_position(new Box2D.b2Vec2(params.x * SCALE, params.y * SCALE));
	bodyDef.set_linearDamping(params.linearDamping);

	fixDef.set_density(params.density);
	fixDef.set_friction(params.friction);
	fixDef.set_restitution(params.restitution);
	
	fixDef.set_shape(shape);

	filter.set_categoryBits(params.categoryBits);
	filter.set_maskBits(params.maskBits);

	var body = addBody(bodyDef, fixDef, params.mesh);
	body.name = params.name;
	return body;
}

var circleParams = {
	name: 'testBall',
	shape: 'circle',
	categoryBits: 2,
	maskBits: 1
}

var pos;
var jumpDistance = 400 * SCALE;
var jumpDistanceHalf = jumpDistance * 0.5;
var despawnDistance = 3000 * SCALE;
var jumpVec = new Box2D.b2Vec2(0, jumpDistance);
var bodiesToDespawn = [];
function update() {

	for (var i = 0; i < prePhysicsCallbacks.length; i++) {
		prePhysicsCallbacks[i]();
	};

	pos = avatar.body.GetPosition();
	var posX = pos.get_x();
	var absPosX = Math.abs(posX);
	var posXDirection = posX < 0 ? 1 : -1;
	if(absPosX > jumpDistanceHalf) {
		//avatar crossed a barrier, teleport everything
		var bodyList = physicsWorld.GetBodyList();
		var total = physicsWorld.GetBodyCount();
		var jumpX = posXDirection * jumpDistance;
		for (var i = total; i >= 0; i--) {
			pos = bodyList.GetPosition();
			if(bodyList !== groundBody) {
				var x = pos.get_x() + jumpX;
				pos.set_x(x);
				bodyList.SetTransform(pos, 0);
				if(Math.abs(x) > despawnDistance) {
					bodiesToDespawn.push(bodyList);
				}
				bodyList = bodyList.GetNext();
			}
		}
		// });
		// avatar.SetTransform(new Box2D.b2Vec2(100 * SCALE, 100 * SCALE), 0);
	}

	bodiesToDespawn.forEach(despawnBody);
	bodiesToDespawn.length = 0;
	physicsWorld.Step(
		1 / 60,   //frame-rate
		2,       //velocity iterations
		2       //position iterations
	);

	bodyMeshes.forEach(function(bodyMesh){
		pos = bodyMesh.body.GetPosition();
		bodyMesh.position.x = pos.get_x() * SCALE_INV;
		bodyMesh.position.y = pos.get_y() * SCALE_INV;
		bodyMesh.rotation.z = bodyMesh.body.GetAngle();
	})


	physicsWorld.ClearForces();
	avatar.updateWalk();
	 
	window.requestAnimationFrame(update);
}
window.requestAnimationFrame(update);

function despawnBody(body) {
	physicsWorld.DestroyBody(body);
	scene.remove(body.bodyMesh);
	var index = bodyMeshes.indexOf(body.bodyMesh);
	bodyMeshes.splice(index, 1);
}

function addJointSpring(params) {
	var jointDef = new Box2D.b2DistanceJointDef();
	jointDef.Initialize(params.bodyA, params.bodyB, params.bodyA.GetPosition(), params.bodyB.GetPosition());
	jointDef.set_frequencyHz(0.65);
	jointDef.set_dampingRatio(1);
	physicsWorld.CreateJoint(jointDef);
}

function addJointFriction(params) {
	var jointDef = new Box2D.b2FrictionJointDef();
	jointDef.Initialize(params.bodyA, params.bodyB, 5);
	jointDef.set_collideConnected(true);
	jointDef.set_maxForce(params.maxForce || 0.35);
	jointDef.set_maxTorque(0.1);
	physicsWorld.CreateJoint(jointDef);
}

function setAvatar(obj) {
	addJointFriction({
		bodyA: obj,
		bodyB: groundBody
	})
	avatar = obj;
}

function getAvatar() {
	return avatar;
}

function registerPrePhysics(callback) {
	prePhysicsCallbacks.push(callback);
}

function getTempVec2() {
	return new Box2D.b2Vec2(0, 0.0000315);
	return tempVec2;
}

function init() {
	if(initd) return;
	initd = true;
	scene = world.scene;
	groundBody = createPhysicsBody({
		name: 'ground',
		shape: 'rectangle',
		width: 6000,
		height: 10,
		friction: 100,
		x: 300,
		y: 10,
		categoryBits: 1,
		maskBits: 3,
		staticBody: true
	});

	for(var i = 0; i < 250; ++i) {
		circleParams.radius = Math.random() * 30 + 10;
		circleParams.x = Math.random() * 6000;
		circleParams.y = Math.random() * 300;
		createPhysicsBody(circleParams);
	}

	exports.Box2D = Box2D;
	exports.physicsWorld = physicsWorld;
	exports.createPhysicsBody = createPhysicsBody;
	exports.addJointSpring = addJointSpring;
	exports.addJointFriction = addJointFriction;
	exports.setAvatar = setAvatar;
	exports.getAvatar = getAvatar;
	exports.registerPrePhysics = registerPrePhysics;
	exports.getTempVec2 = getTempVec2;
	exports.groundBody = groundBody;

	delete exports.init;
}

var exports = {
	init: init,
	SCALE: SCALE,
	SCALE_INV: SCALE_INV
};

module.exports = exports;