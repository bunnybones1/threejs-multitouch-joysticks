var initd = false;

var view = require('view');
var world = require('world');
// var Box2D = require('vendor/box2d');
var Box2DModule = require('vendor/box2d-emscripten');
var Box2D = Box2DModule.Box2D;


var SCALE = 1 / 400;
var SCALE_INV = 1 / SCALE;
function init() {
	if(initd) return;
	initd = true;

	var debugMeshes = [];
	var scene = world.scene;

	var gravity = new Box2D.b2Vec2(0, -4);
	var physicsWorld = new Box2D.b2World(gravity);

	var fixDef = new Box2D.b2FixtureDef();
	fixDef.set_density(1.0);
	fixDef.set_friction(0.5);
	fixDef.set_restitution(0.2);

	var bodyDef = new Box2D.b2BodyDef();
	bodyDef.set_type(Box2D.b2_staticBody);

	bodyDef.set_position(new Box2D.b2Vec2(300 * SCALE, 10 * SCALE));

	var shape = new Box2D.b2PolygonShape();

	fixDef.set_shape(shape);
	   
	// half width, half height.
	shape.SetAsBox(300 * SCALE, 5 * SCALE);
	fixDef.width = 600;
	fixDef.height = 10;

	function addBody(bodyDef, fixDef) {
		var geometry;
		var body = physicsWorld.CreateBody(bodyDef);
		body.CreateFixture(fixDef);
		body.SetAwake(1);
        body.SetActive(1);
		if(fixDef.width && fixDef.height) {
			geometry = new THREE.PlaneGeometry(fixDef.width, fixDef.height, 1, 1);
		} else if(fixDef.radius) {
			geometry = new THREE.SphereGeometry(fixDef.radius, 8, 4);
		} else {
			throw new Error('I don\'t know');
		}
		var debugMesh = new THREE.Mesh(geometry);
		debugMesh.body = body;
		body.debugMesh = debugMesh;
		scene.add(debugMesh);
		debugMeshes.push(debugMesh);
	}

	addBody(bodyDef, fixDef);

	delete fixDef.width;
	delete fixDef.height;

	bodyDef.set_type(Box2D.b2_dynamicBody);
	for(var i = 0; i < 50; ++i) {
		var radius = Math.random() * 30 + 10;
		fixDef.radius = radius;
		shape = new Box2D.b2CircleShape(
			radius * SCALE //radius
		)
		fixDef.set_shape(shape);
		shape.set_m_radius(radius * SCALE);
		bodyDef.set_position(new Box2D.b2Vec2(Math.random() * 600 * SCALE, Math.random() * 300 * SCALE));
		addBody(bodyDef, fixDef);
	}
	function update() {
		physicsWorld.Step(
			1 / 60,   //frame-rate
			2,       //velocity iterations
			2       //position iterations
		);

		var pos;
		debugMeshes.forEach(function(debugMesh){
			pos = debugMesh.body.GetPosition();
			debugMesh.position.x = pos.get_x() * SCALE_INV;
			debugMesh.position.y = pos.get_y() * SCALE_INV;
			debugMesh.rotation.z = debugMesh.body.GetAngle();
		})

		physicsWorld.ClearForces();
		 
		window.requestAnimationFrame(update);
	}
	window.requestAnimationFrame(update);
	delete module.exports.init;
}

module.exports = {
	init: init
};