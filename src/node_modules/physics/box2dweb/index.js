var initd = false;

var view = require('view');
var world = require('world');
var scenery = require('scenery');
var Box2D = require('vendor/box2dweb');
var pathsToFlatten = [
	'Common.Math',
	'Dynamics',
	'Collision.Shapes',
	'Joints'
];

pathsToFlatten.forEach(function(path) {
	var pathParts = path.split('.');
	var source = Box2D;
	while(pathParts.length > 0) source = source[pathParts.shift()];
	Object.keys(source).forEach(function(key) {
		Box2D[key] = source[key];
	})
})
var defaults = require('lodash.defaults');

var SCALE = 1 / 400;
var SCALE_INV = 1 / SCALE;

var ARROW_STICK_IMPULSE_TOLERANCE = 0.002;
var MAX_ENEMIES = 20;

var bodyMeshes = [];
var bodyMeshesWithManualRotationUpdate = [];
var scene;
var avatar;
var groundBody;

var tempVec2 = new Box2D.b2Vec2(0, 0);

var gravity = new Box2D.b2Vec2(0, -4);
var physicsWorld = new Box2D.b2World(gravity);
var b2Listener = Box2D.Dynamics.b2ContactListener;

//Add listeners for contact
var listener = new b2Listener;

listener.BeginContact = function(contact) {
	// console.log(contact.GetFixtureA().GetBody().GetUserData());
}

listener.EndContact = function(contact) {
	// console.log(contact.GetFixtureA().GetBody().GetUserData());
}

listener.PostSolve = function(contact, impulse) {
	var bodyArrow = contact.GetFixtureA().GetBody();
	var bodyTarget = contact.GetFixtureB().GetBody();
	if(bodyArrow.GetUserData() === 'arrow' && bodyTarget.GetUserData() === 'enemy' && impulse.normalImpulses[0] > ARROW_STICK_IMPULSE_TOLERANCE) {
		var meshArrow = bodyArrow.bodyMesh;
		var meshTarget = bodyTarget.bodyMesh;
		if(meshArrow && meshTarget) {
			bodiesToDespawn.push(bodyArrow);
			meshArrow.attachMeshToUponDespawn = meshTarget;
			meshesToDespawn.push(meshArrow);
		}
	}
}

listener.PreSolve = function(contact, oldManifold) {
	// PreSolve
}

physicsWorld.SetContactListener(listener);

var fixDef = new Box2D.b2FixtureDef();
var bodyDef = new Box2D.b2BodyDef();

var filter = fixDef.filter;

var prePhysicsCallbacks = [];

function addBody(bodyDef, fixDef, bodyMesh) {
	var geometry;
	var body = physicsWorld.CreateBody(bodyDef);
	body.CreateFixture(fixDef);
	body.SetAwake(1);
	body.SetActive(1);
	if(!bodyMesh) {
		if(fixDef.width && fixDef.height) {
			geometry = new THREE.PlaneGeometry(fixDef.width, fixDef.height, 1, 1);
		} else if(fixDef.radius) {
			geometry = new THREE.SphereGeometry(fixDef.radius, 8, 4);
		} else {
			throw new Error('Cannot deduce desired shape.');
		}
		bodyMesh = new THREE.Mesh(geometry);
	}
	bodyMesh.body = body;
	body.bodyMesh = bodyMesh;
	scene.add(bodyMesh);
	bodyMeshes.push(bodyMesh);
	if(bodyMesh.updateRotation) {
		bodyMeshesWithManualRotationUpdate.push(bodyMesh);
	}
	return body;
}

var defaultActorParams = {
	shape: 'circle',
	staticBody: false,
	fixedRotation: false,
	mass: 1.0,
	density: 1.0,
	friction: 0.5,
	restitution: 0.2,
	x: 100,
	y: 100,
	angle: 0,
	categoryBits: 1,
	maskBits: 1,
	linearDamping: 0.1,
};

var defaultCircleParams = {
	radius: 50
};

var defaultRectangleParams = {
	width: 50,
	height: 50
};
function addActor(params) {
	defaults(params, defaultActorParams);
	var shape;
	switch(params.shape) {
		case 'circle':
			defaults(params, defaultCircleParams);

			delete fixDef.width;
			delete fixDef.height;
			fixDef.radius = params.radius;

			shape = new Box2D.b2CircleShape();
			shape.m_radius = params.radius * SCALE;
			
			break;
		case 'rectangle':
			defaults(params, defaultRectangleParams);

			delete fixDef.radius;
			fixDef.width = params.width;
			fixDef.height = params.height;

			shape = new Box2D.b2PolygonShape();

			// half width, half height.
			shape.SetAsBox(params.width * 0.5 * SCALE, params.height * 0.5 * SCALE);
			fixDef.width = params.width;
			fixDef.height = params.height;

			break;
		default:
			throw new Error('unkown shape');
	}
	bodyDef.fixedRotation = params.fixedRotation;
	bodyDef.type = params.staticBody ? Box2D.b2Body.b2_staticBody : Box2D.b2Body.b2_dynamicBody;

	bodyDef.position = new Box2D.b2Vec2(params.x * SCALE, params.y * SCALE);
	bodyDef.linearDamping = params.linearDamping;
	bodyDef.bullet = params.bullet;

	fixDef.density = params.density;
	fixDef.friction = params.friction;
	fixDef.restitution = params.restitution;
	
	fixDef.shape = shape;

	filter.categoryBits = params.categoryBits;
	filter.maskBits = params.maskBits;

	var body = addBody(bodyDef, fixDef, params.mesh);
	body.name = params.name;
	return body;
}

var circleParams = {
	name: 'testBall',
	shape: 'circle',
	categoryBits: 4,
	maskBits: 1 | 8
}

var pos;
var jumpDistance = 400 * SCALE;
var jumpDistanceHalf = jumpDistance * 0.5;
var despawnDistance = 3000 * SCALE;
var jumpVec = new Box2D.b2Vec2(0, jumpDistance);
var enemyBodies = [];
var bodiesToDespawn = [];
var meshesToDespawn = [];
function update() {

	for (var i = 0; i < prePhysicsCallbacks.length; i++) {
		prePhysicsCallbacks[i]();
	};

	if(enemyBodies.length < MAX_ENEMIES) {
		spawnEnemy();
	}

	pos = avatar.body.GetPosition();
	var posX = pos.x;
	var absPosX = Math.abs(posX);
	var posXDirection = posX < 0 ? 1 : -1;
	if(absPosX > jumpDistanceHalf) {
		//avatar crossed a barrier, teleport everything
		var bodyList = physicsWorld.GetBodyList();
		var total = physicsWorld.GetBodyCount();
		var jumpX = posXDirection * jumpDistance;
		scenery.teleport(jumpX * SCALE_INV);
		for (var i = total; i >= 0; i--) {
			pos = bodyList.GetPosition();
			if(bodyList !== groundBody) {
				var x = pos.x + jumpX;
				pos.x = x;
				bodyList.SetPosition(pos);
				if(Math.abs(x) > despawnDistance) {
					bodiesToDespawn.push(bodyList);
				}
				bodyList = bodyList.GetNext();
			}
		}
		// });
		// avatar.SetTransform(new Box2D.b2Vec2(100 * SCALE, 100 * SCALE), 0);
	}
	
	physicsWorld.Step(
		1 / 60,   //frame-rate
		2,       //velocity iterations
		2       //position iterations
	);

	bodyMeshes.forEach(function(bodyMesh){
		pos = bodyMesh.body.GetPosition();
		bodyMesh.position.x = pos.x * SCALE_INV;
		bodyMesh.position.y = pos.y * SCALE_INV;
		bodyMesh.rotation.z = bodyMesh.body.GetAngle();
	})

	bodyMeshesWithManualRotationUpdate.forEach(function(bodyMesh) {
		bodyMesh.updateRotation();
	})


	bodiesToDespawn.forEach(function(body) {
		despawnBody(body);
	});
	bodiesToDespawn.length = 0;

	meshesToDespawn.forEach(function(mesh) {
		despawnMesh(mesh);
	});
	meshesToDespawn.length = 0;


	physicsWorld.ClearForces();
	avatar.updateWalk();
	 
	window.requestAnimationFrame(update);
}
window.requestAnimationFrame(update);

function despawnBody(body) {
	physicsWorld.DestroyBody(body);
	var mesh = body.bodyMesh;
	var index = bodyMeshes.indexOf(mesh);
	bodyMeshes.splice(index, 1);
	index = bodyMeshesWithManualRotationUpdate.indexOf(mesh);
	if(index !== -1) {
		bodyMeshesWithManualRotationUpdate.splice(index, 1);
	}
	index = enemyBodies.indexOf(body);
	if(index !== -1) {
		enemyBodies.splice(index, 1);
	}
	mesh.body = null;
	body.mesh = null;
}

function despawnMesh(mesh) {
	if(mesh.attachMeshToUponDespawn) {
		// THREE.SceneUtils.detach(meshArrow, meshArrow.parent, world.scene);
		THREE.SceneUtils.attach(mesh, scene, mesh.attachMeshToUponDespawn);
		mesh.position.normalize().multiplyScalar(mesh.attachMeshToUponDespawn.geometry.parameters.radius);
	} else {
		scene.remove(mesh);
	}
}

function addJointSpring(params) {
	var jointDef = new Box2D.b2DistanceJointDef();
	jointDef.Initialize(params.bodyA, params.bodyB, params.bodyA.GetPosition(), params.bodyB.GetPosition());
	jointDef.frequencyHz = 0.65;
	jointDef.dampingRatio = 1;
	physicsWorld.CreateJoint(jointDef);
}

function setAvatar(obj) {
	avatar = obj;
	// boobyTrap(avatar.body.m_xf.position, 'x');
	// boobyTrap(avatar.body.m_sweep, 'a');
	// boobyTrap(avatar.body, 'm_angularVelocity');
}

function getAvatar() {
	return avatar;
}

function spawnEnemy() {
	circleParams.radius = Math.random() * 30 + 10;
	circleParams.x = Math.random() * 6000;
	circleParams.y = 20 + circleParams.radius;
	var body = addActor(circleParams);
	body.SetUserData('enemy');
	body.m_linearVelocity.x = 1;
	enemyBodies.push(body);
}

function registerPrePhysics(callback) {
	prePhysicsCallbacks.push(callback);
}

function getTempVec2(x, y) {
	tempVec2.x = x;
	tempVec2.y = y;
	return tempVec2;
}

function init() {
	if(initd) return;
	initd = true;
	scene = world.scene;
	groundBody = addActor({
		name: 'ground',
		shape: 'rectangle',
		width: 6000,
		height: 10,
		friction: 100,
		x: 300,
		y: 10,
		categoryBits: 1,
		maskBits: 1 | 2 | 4 | 8 | 16,
		staticBody: true
	});
	groundBody.m_fixtureList.impairVision = true;

	exports.Box2D = Box2D;
	exports.physicsWorld = physicsWorld;
	exports.addActor = addActor;
	exports.addJointSpring = addJointSpring;
	exports.setAvatar = setAvatar;
	exports.getAvatar = getAvatar;
	exports.registerPrePhysics = registerPrePhysics;
	exports.getTempVec2 = getTempVec2;
	exports.groundBody = groundBody;

	delete exports.init;
}

var exports = {
	init: init,
	SCALE: SCALE,
	SCALE_INV: SCALE_INV
};

module.exports = exports;