var initd = false;

var bits = require('../bits');
var scenery;
var Box2D = require('vendor/box2dweb');
var pathsToFlatten = [
	'Common.Math',
	'Dynamics',
	'Collision.Shapes',
	'Joints'
];

pathsToFlatten.forEach(function(path) {
	var pathParts = path.split('.');
	var source = Box2D;
	while(pathParts.length > 0) source = source[pathParts.shift()];
	Object.keys(source).forEach(function(key) {
		Box2D[key] = source[key];
	})
})
var defaults = require('lodash.defaults');

var SCALE = 1 / 400;
var SCALE_INV = 1 / SCALE;

var ARROW_STICK_IMPULSE_TOLERANCE = 0.002;
var MAX_ENEMIES = 10;

var bodyMeshes = [];
var bodyMeshesWithManualRotationUpdate = [];
var scene;
var avatar;
var people = [];
var floorBody;
var ceilingBody;

var tempVec2 = new Box2D.b2Vec2(0, 0);

var gravity = new Box2D.b2Vec2(0, 0);
var physicsWorld = new Box2D.b2World(gravity);

var fixDef = new Box2D.b2FixtureDef();
var bodyDef = new Box2D.b2BodyDef();

var filter = fixDef.filter;

var prePhysicsCallbacks = [];

function addBody(bodyDef, fixDef, bodyMesh) {
	var geometry;
	var body = physicsWorld.CreateBody(bodyDef);
	body.CreateFixture(fixDef);
	body.SetAwake(1);
	body.SetActive(1);
	if(!bodyMesh) {
		if(fixDef.width && fixDef.height) {
			geometry = new THREE.PlaneGeometry(fixDef.width, fixDef.height, 1, 1);
		} else if(fixDef.radius) {
			geometry = new THREE.SphereGeometry(fixDef.radius, 8, 4);
		} else {
			throw new Error('Cannot deduce desired shape.');
		}
		bodyMesh = new THREE.Mesh(geometry);
	}
	bodyMesh.body = body;
	body.bodyMesh = bodyMesh;
	scene.add(bodyMesh);
	bodyMeshes.push(bodyMesh);
	if(bodyMesh.updateRotation) {
		bodyMeshesWithManualRotationUpdate.push(bodyMesh);
	}
	return body;
}

var defaultActorParams = {
	shape: 'circle',
	staticBody: false,
	fixedRotation: false,
	mass: 1.0,
	density: 1.0,
	friction: 0.5,
	restitution: 0.2,
	x: 100,
	y: 100,
	angle: 0,
	categoryBits: 1,
	maskBits: 1,
	linearDamping: 0.1,
};

var defaultCircleParams = {
	radius: 50
};

var defaultRectangleParams = {
	width: 50,
	height: 50
};
function createPhysicsBody(params) {
	defaults(params, defaultActorParams);
	var shape;
	switch(params.shape) {
		case 'circle':
			defaults(params, defaultCircleParams);

			delete fixDef.width;
			delete fixDef.height;
			fixDef.radius = params.radius;

			shape = new Box2D.b2CircleShape();
			shape.m_radius = params.radius * SCALE;
			
			break;
		case 'rectangle':
			defaults(params, defaultRectangleParams);

			delete fixDef.radius;
			fixDef.width = params.width;
			fixDef.height = params.height;

			shape = new Box2D.b2PolygonShape();

			// half width, half height.
			shape.SetAsBox(params.width * 0.5 * SCALE, params.height * 0.5 * SCALE);
			fixDef.width = params.width;
			fixDef.height = params.height;

			break;
		default:
			throw new Error('unkown shape');
	}
	bodyDef.fixedRotation = params.fixedRotation;
	bodyDef.type = params.staticBody ? Box2D.b2Body.b2_staticBody : Box2D.b2Body.b2_dynamicBody;

	bodyDef.position = new Box2D.b2Vec2(params.x * SCALE, params.y * SCALE);
	bodyDef.angularDamping = params.angularDamping;
	bodyDef.linearDamping = params.linearDamping;
	bodyDef.bullet = params.bullet;

	fixDef.density = params.density;
	fixDef.friction = params.friction;
	fixDef.restitution = params.restitution;
	
	fixDef.shape = shape;

	filter.categoryBits = params.categoryBits;
	filter.maskBits = params.maskBits;

	var body = addBody(bodyDef, fixDef, params.mesh);
	body.name = params.name;
	return body;
}

var pos;
var jumpDistance = 400 * SCALE;
var jumpDistanceHalf = jumpDistance * 0.5;
var despawnDistance = 3000 * SCALE;
var jumpVec = new Box2D.b2Vec2(0, jumpDistance);
var bodiesToDespawn = [];
var meshesToDespawn = [];
function update() {

	var i;
	for (i = 0; i < prePhysicsCallbacks.length; i++) {
		prePhysicsCallbacks[i]();
	}
	
	pos = avatar.body.GetPosition();
	var posX = pos.x;
	var absPosX = Math.abs(posX);
	var posXDirection = posX < 0 ? 1 : -1;
	if(absPosX > jumpDistanceHalf) {
		//avatar crossed a barrier, teleport everything
		var bodyList = physicsWorld.GetBodyList();
		var total = physicsWorld.GetBodyCount();
		var jumpX = posXDirection * jumpDistance;
		avatar.desiredLocation.x += jumpX;
		scenery.teleport(jumpX * SCALE_INV);
		for (i = total; i >= 0; i--) {
			pos = bodyList.GetPosition();
			if(bodyList !== floorBody && bodyList !== ceilingBody) {
				var x = pos.x + jumpX;
				pos.x = x;
				bodyList.SetPosition(pos);
				if(Math.abs(x) > despawnDistance) {
					bodiesToDespawn.push(bodyList);
				}
				bodyList = bodyList.GetNext();
			}
		}
		// });
		// avatar.SetTransform(new Box2D.b2Vec2(100 * SCALE, 100 * SCALE), 0);
	}
	
	physicsWorld.Step(
		1 / 60,   //frame-rate
		2,       //velocity iterations
		2       //position iterations
	);

	bodyMeshes.forEach(function(bodyMesh){
		pos = bodyMesh.body.GetPosition();
		bodyMesh.position.x = pos.x * SCALE_INV;
		bodyMesh.position.y = pos.y * SCALE_INV;
		bodyMesh.rotation.z = bodyMesh.body.GetAngle();
		if(bodyMesh.postPhysicsUpdate) {
			bodyMesh.postPhysicsUpdate();
		}
	});

	bodyMeshesWithManualRotationUpdate.forEach(function(bodyMesh) {
		bodyMesh.updateRotation();
	});

	bodiesToDespawn.forEach(function(body) {
		despawnBody(body);
	});
	bodiesToDespawn.length = 0;

	meshesToDespawn.forEach(function(mesh) {
		despawnMesh(mesh);
	});
	meshesToDespawn.length = 0;

	physicsWorld.ClearForces();
	people.forEach(function(person){
		person.updateWalk();
	});
}

function despawnBody(body) {
	physicsWorld.DestroyBody(body);
	var mesh = body.bodyMesh;
	var index = bodyMeshes.indexOf(mesh);
	bodyMeshes.splice(index, 1);
	index = bodyMeshesWithManualRotationUpdate.indexOf(mesh);
	if(index !== -1) {
		bodyMeshesWithManualRotationUpdate.splice(index, 1);
	}
	mesh.body = null;
	body.mesh = null;
}

function despawnMesh(mesh) {
	if(mesh.attachMeshToUponDespawn) {
		// THREE.SceneUtils.detach(meshArrow, meshArrow.parent, world.scene);
		THREE.SceneUtils.attach(mesh, scene, mesh.attachMeshToUponDespawn);
		mesh.position.normalize().multiplyScalar(mesh.attachMeshToUponDespawn.geometry.parameters.radius);
	} else {
		scene.remove(mesh);
	}
}

var temp = new Box2D.b2Vec2(0, 0);
function getClosestEnemyBody(from, cutoffDistance) {
	var closest;
	var closestDistanceSquared = cutoffDistance ? (cutoffDistance*cutoffDistance) : Infinity;
	var pos;
	people.forEach(function(person){
		var body = person.body;
		temp.SetV(from);
		temp.Subtract(body.GetPosition());
		var dist = temp.LengthSquared();
		if(dist < closestDistanceSquared && dist > 0.001) {
			closestDistanceSquared = dist;
			closest = body;
		}
	});
	return closest;
}

function setAvatar(obj) {
	avatar = obj;
	people.push(obj);
	// boobyTrap(avatar.body.m_xf.position, 'x');
	// boobyTrap(avatar.body.m_sweep, 'a');
	// boobyTrap(avatar.body, 'm_angularVelocity');
}

function getAvatar() {
	return avatar;
}

function registerPrePhysics(callback) {
	prePhysicsCallbacks.push(callback);
}

function getTempVec2(x, y) {
	tempVec2.x = x;
	tempVec2.y = y;
	return tempVec2;
}

var wallParams = {
	name: 'wall',
	shape: 'rectangle',
	width: 6000,
	height: 10,
	friction: 100,
	x: 300,
	y: 0,
	categoryBits: bits.environment,
	maskBits: bits.environment | bits.hero | bits.enemy,
	staticBody: true
};

function addPerson(person) {
	people.push(person);
}

function setScenery(obj) {
	scenery = obj;
}

function init(world) {
	if(initd) return;
	initd = true;
	scene = world.scene;
	wallParams.y = -300;
	floorBody = createPhysicsBody(wallParams);
	wallParams.y = 300;
	ceilingBody = createPhysicsBody(wallParams);

	exports.Box2D = Box2D;
	exports.physicsWorld = physicsWorld;
	exports.createPhysicsBody = createPhysicsBody;
	exports.setAvatar = setAvatar;
	exports.getAvatar = getAvatar;
	exports.addPerson = addPerson;
	exports.registerPrePhysics = registerPrePhysics;
	exports.getTempVec2 = getTempVec2;
	exports.floorBody = floorBody;
	exports.getClosestEnemyBody = getClosestEnemyBody;
	exports.ceilingBody = ceilingBody;
	exports.update = update;
	exports.setScenery = setScenery;

	delete exports.init;
}

var exports = {
	init: init,
	SCALE: SCALE,
	SCALE_INV: SCALE_INV
};

module.exports = exports;