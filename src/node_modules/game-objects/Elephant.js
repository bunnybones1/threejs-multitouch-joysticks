var defaults = require('lodash.defaults');
var physics = require('physics');
var world = require('world');
var three = require('three');
var Arrow = require('./Arrow');

var defaultActorParams = {
	name: 'elephant',
	shape: 'circle',
	radius: 60,
	mass: 100,
	friction: 0,
	x: 300,
	y: 100,
	categoryBits: 2,
	maskBits: 1,
	fixedRotation: true,
	linearDamping: 1
};

var rayPoint1;
var rayPoint2;

function Elephant(params) {
	params = params || {};
	this.walkForce = new physics.Box2D.b2Vec2(0.075, 0);
	this.walking = true;
	defaults(params, defaultActorParams);
	this.body = physics.addActor(params);
	this.fixture = this.body.GetFixtureList();
	if(!rayPoint1) {
		rayPoint1 = new physics.Box2D.b2Vec2();
		rayPoint2 = new physics.Box2D.b2Vec2();
	}
	this.sightBounds = new three.Box2();
	this.sightMeshes = [];
	this.jumpForce = new physics.Box2D.b2Vec2(0, 10);
	this.handleRay = this.handleRay.bind(this);
	this.archerOffset = 0.175;

	this.arrows = [];
	this.fireArrow = this.fireArrow.bind(this);
}

Elephant.prototype.look = function() {
	var pos = this.body.GetPosition();
	var x = pos.x;
	var y = pos.y;
	rayPoint1.x = x;
	rayPoint1.y = y;
	// console.log(rayPoint1.x,rayPoint1.y,rayPoint2.x,rayPoint2.y);
	// var groundFixture = physics.groundBody.GetFixtureList();
	// var cb = new physics.Box2D.b2RayCastCallback(this.handleRay);
	// cb.ReportFixture = this.handleRay;
	// groundFixture.RayCast(this.handleRay, rayPoint1, rayPoint2);
	this.castSightRay(x, y, 0, -.5, 0);
	this.castSightRay(x, y, -.4, -.2, 1);
	this.castSightRay(x, y, .4, -.2, 2);
	var groundSight = this.getSightMesh(0).position;
	this.castSightRay(groundSight.x * physics.SCALE, groundSight.y * physics.SCALE, 0, .7, 3);
	// if(Math.random() < 0.01) {
	// 	this.body.ApplyForce(this.jumpForce, this.body.GetPosition());
	// }
	var bounds = this.sightBounds;
	bounds.makeEmpty();
	this.sightMeshes.forEach(function(sightMesh) {
		bounds.expandByPoint(sightMesh.position);
	});
}

Elephant.prototype.castSightRay = function(x, y, vecX, vecY, index) {
	rayPoint2.x = x + vecX;
	rayPoint2.y = y + vecY;
	this.nearestPoint = null;
	physics.physicsWorld.RayCast(this.handleRay, rayPoint1, rayPoint2);
	if(this.nearestPoint) {
		this.getSightMesh(index).position.set(this.nearestPoint.x * physics.SCALE_INV, this.nearestPoint.y * physics.SCALE_INV, 10);
	} else {
		this.getSightMesh(index).position.set((x+vecX) * physics.SCALE_INV, (y+vecY) * physics.SCALE_INV, 10);
	}
};

var geometry;
function getGeometry() {
	if(!geometry) {
		geometry = new three.PlaneGeometry(20, 20, 1, 1);
	}
	return geometry;
}
var material;
function getMaterial() {
	if(!material) {
		material = new three.MeshBasicMaterial({
			wireframe: true,
			color: 0xffffff
		});
	}
	return material;
}
Elephant.prototype.getSightMesh = function(index) {
	if(!this.sightMeshes[index]){
		this.sightMeshes[index] = new three.Mesh(getGeometry(), getMaterial());
		world.scene.add(this.sightMeshes[index]);
	}
	return this.sightMeshes[index];
}

Elephant.prototype.getSightBounds = function() {
	return this.sightBounds;
}

Elephant.prototype.handleRay = function(fixture, point, normal, fraction) {
	if(!fixture.impairVision) return -1;
	this.nearestPoint = point;
	return fraction;
};

Elephant.prototype.walk = function(value) {
	if(value === 0) {
		this.walking = false;
		this.fixture.SetFriction(1000);
	} else {
		this.walking = true;
		this.fixture.SetFriction(0);
		this.walkForce.x = (value * physics.SCALE);
	}
};

Elephant.prototype.updateWalk = function() {
	this.look();
	if(!this.walking) {
		this.walkForce.x = (-this.body.GetLinearVelocity().x * 0.5);
	}
	this.body.ApplyForce(this.walkForce, this.body.GetPosition());
}

Elephant.prototype.fireArrow = function(vx, vy) {
	console.log('Elephire!!', vx, vy);
	position = this.body.GetPosition();
	var arrow = new Arrow({
		x: position.x * physics.SCALE_INV,
		y: (position.y + this.archerOffset) * physics.SCALE_INV,
		vx: this.body.m_linearVelocity.x * 0.04 - vx,
		vy: this.body.m_linearVelocity.y * 0.04 - vy,
		callback: this.onArrowHit
	});
	this.arrows.push(arrow);
}

Elephant.prototype.onArrowHit = function(arrow) {
	debugger;
}

module.exports = Elephant;