var Person = require('./Person');
var Fist = require('./Fist');
var bits = require('physics/bits');
var defaults = require('lodash.defaults');
var physics = require('physics');
var clamp = require('clamp');

var defaultFistParams = {
	categoryBits: bits.enemyWeapon,
	maskBits: bits.environment | bits.hero,
	side: 1
};

function Fighter(params) {
	params = params || {};
	Person.call(this, params);
	this.mesh.postPhysicsUpdate = this.postPhysicsUpdate.bind(this);
	var fistParams = params.fistParams || {};
	if(!fistParams.material) {
		fistParams.material = this.getMaterial();
	}
	defaults(fistParams, defaultFistParams);
	// fistParams.fighter = this;
	this.attackSpeed = Math.random() * 0.02 + 0.01;
	this.weapons = [];
	fistParams.color = this.colorSkin;
	fistParams.color2 = this.colorSkin2;
	fistParams.z = this.armHeight;
	fistParams.side = 1;
	this.addWeapon(new Fist(fistParams));
	fistParams.side = -1;
	this.addWeapon(new Fist(fistParams));
}

Fighter.prototype = Object.create(Person.prototype);

Fighter.prototype.addWeapon = function(weapon) {
	this.weapons.push(weapon);
	var def = new physics.Box2D.b2PrismaticJointDef();
	def.bodyA = this.body;
	def.bodyB = weapon.body;
	def.localAnchorB.y = this.weapons.length === 1 ? 0.03 : -0.03;
	def.enableLimit = true;
	def.upperTranslation = 0.15;
	def.enableMotor = true;
	def.maxMotorForce = 0.2;
	var joint = physics.physicsWorld.CreateJoint(def);
	weapon.arm = this.arms[this.weapons.length-1];
	weapon.armLength = weapon.arm.scale.x;
	weapon.armHomeY = weapon.arm.position.y;
	weapon.joint = joint;
};

// var temp = new physics.Box2D.b2Vec2(0,0);
Fighter.prototype.updateWalk = function() {
	Person.prototype.updateWalk.call(this);
	var attackSpeed = this.attackSpeed;
	var target = this.target;
	var targetIsCloseEnough = this.targetIsCloseEnough;
	this.weapons.forEach(function(weapon, i){
		if(target && targetIsCloseEnough) {
			var time = Date.now();
			var wave = Math.sin(time * attackSpeed * weapon.speed + Math.PI * i);
			var power = (wave > 0.65 ? 3 : -1) * weapon.speed;
			weapon.isAttacking = power > 0;
			weapon.joint.SetMotorSpeed(power);
		} else {
			weapon.joint.SetMotorSpeed(-1);
		}
	});
	// if(this.target) {
	// 	var currLocation = this.body.GetPosition();
	// 	if(this.target.GetPosition()) {

	// 	}
	// }
};

Fighter.prototype.postPhysicsUpdate = function() {
	var armHeight = this.armHeight;
	this.weapons.forEach(function(weapon){
		var bodyMesh = weapon.mesh;
		var amt = weapon.joint.GetJointTranslation() * 6;
		var arm = weapon.arm;
		arm.scale.x = weapon.armLength * amt + 30;
		arm.scale.z = Math.max(20, (1-amt) * weapon.armLength * 0.7);
		arm.position.z = armHeight - (arm.scale.z - 20);
		arm.position.x = arm.scale.x * 0.5 - 10;
	});
};

Fighter.prototype.attack = function() {

};
module.exports = Fighter;